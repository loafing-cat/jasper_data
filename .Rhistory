) %>%
select(-line) %>%  # remove the original line column
filter(!is.na(metric))  # exclude entries without metric names
return(data_frame)
}
# parse and label hematology and chemistry data, trimming any whitespace
hematology_df <- parse_section(hematology_text) %>%
mutate(test = "hematology") %>%
mutate_all(str_trim)
chemistry_df <- parse_section(chemistry_text) %>%
mutate(test = "chemistry") %>%
mutate_all(str_trim)
# combine hematology and chemistry data, and rename metrics that weren't extracted correctly
results <- bind_rows(hematology_df, chemistry_df) %>%
mutate(metric = case_when(
metric == "BUN: Creatinine" ~ "BUN: Creatinine Ratio",
metric == "Albumin:" ~ "Albumin: Globulin Ratio",
TRUE ~ metric
))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.Date(date_of_result),
test = as.character(test)
)
# create a date variable with different format for exporting
date_for_export <- format(as.Date(formatted_date), "%Y_%m_%d")
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
# need to load in old csv file with pattern `cbc_chem_updated_` and then append data from the `results` dataframe to it and then overwrite the loaded file
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
if (length(file_name) == 1) {
old_data <- import(file_name)
updated_data <- bind_rows(old_data, results)
export(updated_data, file_name)
} else {
message("Error: The file expected to be updated was not found!")
}
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
old_data <- import(here("output data", "cbc_chem_2024_05_10.csv"))
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
# need to load in old csv file with pattern `cbc_chem_updated_` and then append data from the `results` dataframe to it and then overwrite the loaded file
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
if (length(file_name) == 1) {
old_data <- import(file_name)
updated_data <- bind_rows(old_data, results)
export(updated_data, file_name)
} else {
message("Error: The file expected to be updated was not found!")
}
tibble(old_data)
tibble(results)
temp = import(here("output data", "cbc_chem_2024_05_10.csv"))
tibble(temp)
# clear environment
rm(list = ls()); gc()
# load necessary libraries
pacman::p_load(tidyverse, pdftools, here, rio, lubridate, data.table)
# specify path to PDF file and read its content
pdf_path <- here("input text data")
raw_text <- pdf_text(here(pdf_path, "dessert_ridge_blood_chem_06_08_2024.pdf"))
# extract all dates labeled 'date of result'; used to date when metrics reported
dates_of_result <- str_extract_all(raw_text, "\\s*DATE OF RESULT:\\s*(\\d{1,2}/\\d{1,2}/\\d{2})")[[1]] %>%
print()
# clean 1st instance of date string by removing preceding text
date_of_result <- str_replace(dates_of_result[1], ".*DATE OF RESULT:\\s*", "")
# reformat date
formatted_date <- mdy(date_of_result) %>%
format("%Y-%m-%d") %>%
print()
# function to clean text by removing unnecessary headers, footers, and other repetitive details
clean_text <- function(text) {
text %>%
str_replace_all("Generated by VetConnect.*", "") %>%
str_replace_all("JASPER THAI.*", "") %>%
str_replace_all("PET OWNER: DIANE THAI.*", "") %>%
str_split("\n") %>%  # split the string into separate lines
unlist() %>%  # convert the list of lines into a vector
str_trim() %>%  # trim whitespace
.[. != ""]  # remove empty lines
}
# apply cleaning function to raw text
cleaned_text <- clean_text(raw_text)
# determine start indices for hematology and chemistry sections and partition cleaned text accordingly
hematology_start <- which(cleaned_text == "Hematology")
chemistry_start <- which(cleaned_text == "Chemistry")
hematology_text <- cleaned_text[hematology_start:(chemistry_start - 1)]
chemistry_text <- cleaned_text[(chemistry_start + 1):length(cleaned_text)]
# print each line of the hematology section to observe structure
for (line in hematology_text) {
cat(line, "\n")
}
# function to parse cleaned text into a dataframe, extracting metrics and values
parse_section <- function(section_text) {
data_frame <- tibble(line = section_text) %>%
filter(str_detect(line, "\\d")) %>% # filter out rows with non-numeric values
mutate(
metric = str_extract(line, "^[^\\d\\r\\n]+(?=\\s*\\d)"),  # extract metric names, avoiding numbers
value = str_extract(line, "\\s*(\\d+\\.?\\d*)"),  # extract numeric values
date_of_result = formatted_date  # append the formatted date to each entry
) %>%
select(-line) %>%  # remove the original line column
filter(!is.na(metric))  # exclude entries without metric names
return(data_frame)
}
# parse and label hematology and chemistry data, trimming any whitespace
hematology_df <- parse_section(hematology_text) %>%
mutate(test = "hematology") %>%
mutate_all(str_trim)
chemistry_df <- parse_section(chemistry_text) %>%
mutate(test = "chemistry") %>%
mutate_all(str_trim)
# combine hematology and chemistry data, and rename metrics that weren't extracted correctly
results <- bind_rows(hematology_df, chemistry_df) %>%
mutate(metric = case_when(
metric == "BUN: Creatinine" ~ "BUN: Creatinine Ratio",
metric == "Albumin:" ~ "Albumin: Globulin Ratio",
TRUE ~ metric
))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test)
)
# create a date variable with different format for exporting
date_for_export <- format(as.Date(formatted_date), "%Y_%m_%d")
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
old_data <- import(here("output data", "cbc_chem_2024_05_10.csv"))
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
# need to load in old csv file with pattern `cbc_chem_updated_` and then append data from the `results` dataframe to it and then overwrite the loaded file
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
if (length(file_name) == 1) {
old_data <- import(file_name)
updated_data <- bind_rows(old_data, results)
export(updated_data, file_name)
} else {
message("Error: The file expected to be updated was not found!")
}
table(updated_data$metric)
# clear environment
rm(list = ls()); gc()
# load necessary libraries
pacman::p_load(tidyverse, pdftools, here, rio, lubridate, data.table)
# specify path to PDF file and read its content
pdf_path <- here("input text data")
raw_text <- pdf_text(here(pdf_path, "dessert_ridge_blood_chem_06_08_2024.pdf"))
# extract all dates labeled 'date of result'; used to date when metrics reported
dates_of_result <- str_extract_all(raw_text, "\\s*DATE OF RESULT:\\s*(\\d{1,2}/\\d{1,2}/\\d{2})")[[1]] %>%
print()
# clean 1st instance of date string by removing preceding text
date_of_result <- str_replace(dates_of_result[1], ".*DATE OF RESULT:\\s*", "")
# reformat date
formatted_date <- mdy(date_of_result) %>%
format("%Y-%m-%d") %>%
print()
# function to clean text by removing unnecessary headers, footers, and other repetitive details
clean_text <- function(text) {
text %>%
str_replace_all("Generated by VetConnect.*", "") %>%
str_replace_all("JASPER THAI.*", "") %>%
str_replace_all("PET OWNER: DIANE THAI.*", "") %>%
str_split("\n") %>%  # split the string into separate lines
unlist() %>%  # convert the list of lines into a vector
str_trim() %>%  # trim whitespace
.[. != ""]  # remove empty lines
}
# apply cleaning function to raw text
cleaned_text <- clean_text(raw_text)
# determine start indices for hematology and chemistry sections and partition cleaned text accordingly
hematology_start <- which(cleaned_text == "Hematology")
chemistry_start <- which(cleaned_text == "Chemistry")
hematology_text <- cleaned_text[hematology_start:(chemistry_start - 1)]
chemistry_text <- cleaned_text[(chemistry_start + 1):length(cleaned_text)]
# print each line of the hematology section to observe structure
for (line in hematology_text) {
cat(line, "\n")
}
# function to parse cleaned text into a dataframe, extracting metrics and values
parse_section <- function(section_text) {
data_frame <- tibble(line = section_text) %>%
filter(str_detect(line, "\\d")) %>% # filter out rows with non-numeric values
mutate(
metric = str_extract(line, "^[^\\d\\r\\n]+(?=\\s*\\d)"),  # extract metric names, avoiding numbers
value = str_extract(line, "\\s*(\\d+\\.?\\d*)"),  # extract numeric values
date_of_result = formatted_date  # append the formatted date to each entry
) %>%
select(-line) %>%  # remove the original line column
filter(!is.na(metric))  # exclude entries without metric names
return(data_frame)
}
# parse and label hematology and chemistry data, trimming any whitespace
hematology_df <- parse_section(hematology_text) %>%
mutate(test = "hematology") %>%
mutate_all(str_trim)
chemistry_df <- parse_section(chemistry_text) %>%
mutate(test = "chemistry") %>%
mutate_all(str_trim)
# combine hematology and chemistry data, and rename metrics that weren't extracted correctly
results <- bind_rows(hematology_df, chemistry_df) %>%
mutate(metric = case_when(
metric == "BUN: Creatinine" ~ "BUN: Creatinine Ratio",
metric == "Albumin:" ~ "Albumin: Globulin Ratio",
TRUE ~ metric
))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test)
)
# create a date variable with different format for exporting
date_for_export <- format(as.Date(formatted_date), "%Y_%m_%d")
# write data to .Rdata file; append date of results to end of file name
export(results, here("output data", paste0("cbc_chem_", date_for_export, ".Rdata")))
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
old_data <- import(here("output data", "cbc_chem_2024_05_10.csv"))
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
# need to load in old csv file with pattern `cbc_chem_updated_` and then append data from the `results` dataframe to it and then overwrite the loaded file
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
if (length(file_name) == 1) {
old_data <- import(file_name)
updated_data <- bind_rows(old_data, results)
export(updated_data, file_name)
} else {
message("Error: The file expected to be updated was not found!")
}
str(file_name)
typeof(file_name)
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test),
date_updated = as.IDate(date_updated)
)
# add an updated date column
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test),
date_updated = as.IDate(date_updated)
)
date_updated
# add an updated date column
date_updated_col <- format(as.Date(Sys.Date()))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test),
date_updated = as.IDate(date_updated_col)
)
sults
results
# clear environment
rm(list = ls()); gc()
# load necessary libraries
pacman::p_load(tidyverse, pdftools, here, rio, lubridate, data.table)
# specify path to PDF file and read its content
pdf_path <- here("input text data")
raw_text <- pdf_text(here(pdf_path, "dessert_ridge_blood_chem_06_08_2024.pdf"))
# extract all dates labeled 'date of result'; used to date when metrics reported
dates_of_result <- str_extract_all(raw_text, "\\s*DATE OF RESULT:\\s*(\\d{1,2}/\\d{1,2}/\\d{2})")[[1]] %>%
print()
# clean 1st instance of date string by removing preceding text
date_of_result <- str_replace(dates_of_result[1], ".*DATE OF RESULT:\\s*", "")
# reformat date
formatted_date <- mdy(date_of_result) %>%
format("%Y-%m-%d") %>%
print()
# function to clean text by removing unnecessary headers, footers, and other repetitive details
clean_text <- function(text) {
text %>%
str_replace_all("Generated by VetConnect.*", "") %>%
str_replace_all("JASPER THAI.*", "") %>%
str_replace_all("PET OWNER: DIANE THAI.*", "") %>%
str_split("\n") %>%  # split the string into separate lines
unlist() %>%  # convert the list of lines into a vector
str_trim() %>%  # trim whitespace
.[. != ""]  # remove empty lines
}
# apply cleaning function to raw text
cleaned_text <- clean_text(raw_text)
# determine start indices for hematology and chemistry sections and partition cleaned text accordingly
hematology_start <- which(cleaned_text == "Hematology")
chemistry_start <- which(cleaned_text == "Chemistry")
hematology_text <- cleaned_text[hematology_start:(chemistry_start - 1)]
chemistry_text <- cleaned_text[(chemistry_start + 1):length(cleaned_text)]
# print each line of the hematology section to observe structure
for (line in hematology_text) {
cat(line, "\n")
}
# function to parse cleaned text into a dataframe, extracting metrics and values
parse_section <- function(section_text) {
data_frame <- tibble(line = section_text) %>%
filter(str_detect(line, "\\d")) %>% # filter out rows with non-numeric values
mutate(
metric = str_extract(line, "^[^\\d\\r\\n]+(?=\\s*\\d)"),  # extract metric names, avoiding numbers
value = str_extract(line, "\\s*(\\d+\\.?\\d*)"),  # extract numeric values
date_of_result = formatted_date  # append the formatted date to each entry
) %>%
select(-line) %>%  # remove the original line column
filter(!is.na(metric))  # exclude entries without metric names
return(data_frame)
}
# parse and label hematology and chemistry data, trimming any whitespace
hematology_df <- parse_section(hematology_text) %>%
mutate(test = "hematology") %>%
mutate_all(str_trim)
chemistry_df <- parse_section(chemistry_text) %>%
mutate(test = "chemistry") %>%
mutate_all(str_trim)
# combine hematology and chemistry data, and rename metrics that weren't extracted correctly
results <- bind_rows(hematology_df, chemistry_df) %>%
mutate(metric = case_when(
metric == "BUN: Creatinine" ~ "BUN: Creatinine Ratio",
metric == "Albumin:" ~ "Albumin: Globulin Ratio",
TRUE ~ metric
))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test)
)
# create a date variable with different format for exporting
date_for_export <- format(as.Date(formatted_date), "%Y_%m_%d")
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
# add an updated date column
date_updated_col <- format(as.Date(Sys.Date()))
old_data <- import(here("output data", "cbc_chem_2024_05_10.csv"))
export(old_data, here("output data", paste0("cbc_chem_updated_", date_updated, ".csv")), row.names = FALSE, col.names = TRUE)
## need to continuously update file containing all of the hematology and chemistry data: file will be labeled with pattern `cbc_chem_updated_*`
# if said file exists in directory, assign to `file_name` which will be used in an if/else
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
# there should only be one file that captures all of the hematology/chemistry updates over time; if length is 1 do the following:
if (length(file_name) == 1) {
# import it
old_data <- import(file_name)
# add new data stored in `results` below the last data placed into file
updated_data <- bind_rows(old_data, results) %>%
mutate(date_updated = as.IDate(date_updated_col))
# then then overwrite the file
export(updated_data, file_name)
} else {
# otherwise throw the following error message
message("Error: The file expected to be updated was not found!")
}
# clear environment
rm(list = ls()); gc()
# load necessary libraries
pacman::p_load(tidyverse, pdftools, here, rio, lubridate, data.table)
# specify path to PDF file and read its content
pdf_path <- here("input text data")
raw_text <- pdf_text(here(pdf_path, "dessert_ridge_blood_chem_06_08_2024.pdf"))
# extract all dates labeled 'date of result'; used to date when metrics reported
dates_of_result <- str_extract_all(raw_text, "\\s*DATE OF RESULT:\\s*(\\d{1,2}/\\d{1,2}/\\d{2})")[[1]] %>%
print()
# clean 1st instance of date string by removing preceding text
date_of_result <- str_replace(dates_of_result[1], ".*DATE OF RESULT:\\s*", "")
# reformat date
formatted_date <- mdy(date_of_result) %>%
format("%Y-%m-%d") %>%
print()
# function to clean text by removing unnecessary headers, footers, and other repetitive details
clean_text <- function(text) {
text %>%
str_replace_all("Generated by VetConnect.*", "") %>%
str_replace_all("JASPER THAI.*", "") %>%
str_replace_all("PET OWNER: DIANE THAI.*", "") %>%
str_split("\n") %>%  # split the string into separate lines
unlist() %>%  # convert the list of lines into a vector
str_trim() %>%  # trim whitespace
.[. != ""]  # remove empty lines
}
# apply cleaning function to raw text
cleaned_text <- clean_text(raw_text)
# determine start indices for hematology and chemistry sections and partition cleaned text accordingly
hematology_start <- which(cleaned_text == "Hematology")
chemistry_start <- which(cleaned_text == "Chemistry")
hematology_text <- cleaned_text[hematology_start:(chemistry_start - 1)]
chemistry_text <- cleaned_text[(chemistry_start + 1):length(cleaned_text)]
# print each line of the hematology section to observe structure
for (line in hematology_text) {
cat(line, "\n")
}
# function to parse cleaned text into a dataframe, extracting metrics and values
parse_section <- function(section_text) {
data_frame <- tibble(line = section_text) %>%
filter(str_detect(line, "\\d")) %>% # filter out rows with non-numeric values
mutate(
metric = str_extract(line, "^[^\\d\\r\\n]+(?=\\s*\\d)"),  # extract metric names, avoiding numbers
value = str_extract(line, "\\s*(\\d+\\.?\\d*)"),  # extract numeric values
date_of_result = formatted_date  # append the formatted date to each entry
) %>%
select(-line) %>%  # remove the original line column
filter(!is.na(metric))  # exclude entries without metric names
return(data_frame)
}
# parse and label hematology and chemistry data, trimming any whitespace
hematology_df <- parse_section(hematology_text) %>%
mutate(test = "hematology") %>%
mutate_all(str_trim)
chemistry_df <- parse_section(chemistry_text) %>%
mutate(test = "chemistry") %>%
mutate_all(str_trim)
# combine hematology and chemistry data, and rename metrics that weren't extracted correctly
results <- bind_rows(hematology_df, chemistry_df) %>%
mutate(metric = case_when(
metric == "BUN: Creatinine" ~ "BUN: Creatinine Ratio",
metric == "Albumin:" ~ "Albumin: Globulin Ratio",
TRUE ~ metric
))
# specify variable datatypes
results <- results %>%
mutate(
metric = as.character(metric),
value = as.numeric(value),
date_of_result = as.IDate(date_of_result),
test = as.character(test)
)
# create a date variable with different format for exporting
date_for_export <- format(as.Date(formatted_date), "%Y_%m_%d")
# do some clean up and data management
date_updated <- format(as.Date(Sys.Date()), "%Y_%m_%d")
# add an updated date column
date_updated_col <- format(as.Date(Sys.Date()))
old_data <- import(here("output data", "cbc_chem_2024_05_10.csv"))
export(old_data, here("output data", "cbc_chem_updated.csv"), row.names = FALSE, col.names = TRUE)
## need to continuously update file containing all of the hematology and chemistry data: file will be labeled with pattern `cbc_chem_updated_*`
# if said file exists in directory, assign to `file_name` which will be used in an if/else
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated_.*\\.csv",
full.names = TRUE
)
# there should only be one file that captures all of the hematology/chemistry updates over time; if length is 1 do the following:
if (length(file_name) == 1) {
# import it
old_data <- import(file_name)
# add new data stored in `results` below the last data placed into file
updated_data <- bind_rows(old_data, results) %>%
mutate(date_updated = as.IDate(date_updated_col))
# then then overwrite the file
export(updated_data, file_name)
} else {
# otherwise throw the following error message
message("Error: The file expected to be updated was not found!")
}
## need to continuously update file containing all of the hematology and chemistry data: file will be labeled with pattern `cbc_chem_updated_*`
# if said file exists in directory, assign to `file_name` which will be used in an if/else
file_name <- list.files(
path = here("output data"),
pattern = "cbc_chem_updated.*\\.csv",
full.names = TRUE
)
# there should only be one file that captures all of the hematology/chemistry updates over time; if length is 1 do the following:
if (length(file_name) == 1) {
# import it
old_data <- import(file_name)
# add new data stored in `results` below the last data placed into file
updated_data <- bind_rows(old_data, results) %>%
mutate(date_updated = as.IDate(date_updated_col))
# then then overwrite the file
export(updated_data, file_name)
} else {
# otherwise throw the following error message
message("Error: The file expected to be updated was not found!")
}
